{"version":3,"file":"CoreAutocomplete-GmrZHgqm.js","sources":["../../src/component/autocomplete/hooks/useInputState.ts","../../src/component/autocomplete/hooks/useItemModel.ts","../../src/component/autocomplete/internal/filter.ts","../../src/component/autocomplete/internal/CoreAutocomplete.tsx"],"sourcesContent":["import { InputDomRef, Ui5CustomEvent } from \"@ui5/webcomponents-react\";\nimport { FocusEvent, useCallback, useEffect, useState } from \"react\";\n\nimport { useLatestRef } from \"../../../hook/useLatestRef\";\nimport { CoreAutocompleteProps } from \"../internal/CoreAutocomplete\";\n\nexport const useInputState = <\n  TModel,\n  TAdditionalProps extends CoreAutocompleteProps<TModel>\n>(\n  props: TAdditionalProps\n): TAdditionalProps => {\n  const {\n    inputValue: propsInputValue,\n    value: propsValue,\n    onInputChange: propsOnInputChange,\n    onValueChange: propsOnValueChange,\n    onBlur: propsOnBlur,\n    forceSelection = true,\n  } = props;\n\n  const [stateInputValue, setStateInputValue] = useState<string | undefined>(\n    propsInputValue !== undefined ? propsInputValue : \"\" // todo defaultInputValue?\n  );\n  const [stateValue, setStateValue] = useState<string | undefined>(\n    propsValue !== undefined ? propsValue : undefined // todo defaultValue?\n  );\n\n  const latestValueRef = useLatestRef(stateValue);\n\n  useEffect(() => {\n    setStateInputValue(propsInputValue ?? \"\");\n  }, [propsInputValue, setStateInputValue]);\n\n  useEffect(() => {\n    setStateInputValue(propsInputValue ?? \"\");\n    setStateValue(propsValue);\n  }, [propsValue, setStateValue]);\n\n  const onInputChange = useCallback(\n    (inputValue: string, event: Ui5CustomEvent<InputDomRef>) => {\n      if (propsOnInputChange != null) {\n        propsOnInputChange(inputValue, event);\n      }\n\n      setStateInputValue(inputValue);\n    },\n    [setStateInputValue, propsOnInputChange]\n  );\n\n  const onValueChange = useCallback(\n    (value?: string, item?: TModel) => {\n      if (propsOnValueChange != null) {\n        propsOnValueChange(value, item);\n      }\n\n      setStateValue(value);\n    },\n    [setStateValue, propsOnValueChange]\n  );\n\n  const onBlur = useCallback(\n    (event: FocusEvent<HTMLInputElement>) => {\n      if (propsOnBlur != null) {\n        propsOnBlur(event);\n      }\n\n      // reset display value when user leaves the field and there is no selected value\n      if (\n        forceSelection &&\n        latestValueRef.current == null &&\n        event.currentTarget.value != \"\"\n      ) {\n        setStateInputValue(\"\");\n      }\n\n      // trigger onValue if selection is not forced\n      if (\n        !forceSelection &&\n        latestValueRef.current !== event.currentTarget.value\n      ) {\n        onValueChange(event.currentTarget.value);\n      }\n    },\n    [setStateValue, propsOnBlur, onValueChange, forceSelection]\n  );\n\n  return {\n    ...props,\n    inputValue: stateInputValue,\n    value: stateValue,\n    onInputChange,\n    onValueChange,\n    onBlur,\n  };\n};\n","import { useCallback } from \"react\";\n\nimport {\n  DEFAULT_LABEL_PROP,\n  DEFAULT_VALUE_PROP,\n} from \"../../common/CommonSelection\";\nimport {\n  CoreAutocompleteProps,\n  DefaultAutoCompleteOption,\n} from \"../internal/CoreAutocomplete\";\n\nexport type UseItemModelManagedPropKeys = keyof Pick<\n  CoreAutocompleteProps,\n  \"getItemLabel\" | \"getItemValue\"\n>;\n\nexport type UseItemAdditionalProps<TItemModel> = {\n  /**\n   * Controls which text is used to display options.\n   * Used by suggestions, if not overridden\n   * by <code>renderSuggestion</code>\n   *\n   * By default the prop <code>label</code> is used.\n   * You can pass either a string, which represents a different prop or a render function.\n   */\n  itemLabel?: string | ((value: TItemModel) => string);\n\n  /**\n   * Controls which value / key is used to identify an option.\n   * This is used by suggestions, if not overridden\n   * by <code>renderSuggestion</code>.\n   *\n   * By default the prop <code>value</code> is used.\n   * You can pass either a string, which represents a different prop or a render function.\n   */\n  itemValue?: string | ((value: TItemModel) => string);\n};\n\ntype UseItemAdditionalPropKeys = keyof UseItemAdditionalProps<{}>;\n\nexport type UseItemModelProps<TItemModel, TAdditionalProps> = Omit<\n  TAdditionalProps,\n  UseItemModelManagedPropKeys\n> &\n  UseItemAdditionalProps<TItemModel>;\n\nexport type UseItemModelReturn<TItemModel, TAdditionalProps> = Omit<\n  TAdditionalProps,\n  UseItemAdditionalPropKeys\n> &\n  Required<\n    Pick<CoreAutocompleteProps<TItemModel>, UseItemModelManagedPropKeys>\n  >;\n\nexport const useItemModel = <TItemModel, TAdditionalProps extends {}>(\n  props: UseItemModelProps<TItemModel, TAdditionalProps>\n): UseItemModelReturn<TItemModel, TAdditionalProps> => {\n  const { itemValue, itemLabel, ...otherProps } = props;\n\n  const getItemLabel = useCallback(\n    (item: TItemModel): string => {\n      if (itemLabel) {\n        if (typeof itemLabel === \"string\") {\n          return item[itemLabel as keyof TItemModel] as unknown as string;\n        } else if (typeof itemLabel === \"function\") {\n          return itemLabel(item);\n        }\n      }\n      return (item as unknown as DefaultAutoCompleteOption)[\n        DEFAULT_LABEL_PROP\n      ] as unknown as string;\n    },\n    [itemLabel]\n  );\n\n  const getItemValue = useCallback(\n    (item: TItemModel): string => {\n      if (itemValue) {\n        if (typeof itemValue === \"string\") {\n          return item[itemValue as keyof TItemModel] as unknown as string;\n        } else if (typeof itemValue === \"function\") {\n          return itemValue(item);\n        }\n      }\n      return (item as unknown as DefaultAutoCompleteOption)[\n        DEFAULT_VALUE_PROP\n      ] as unknown as string;\n    },\n    [itemLabel]\n  );\n\n  // todo typescript!\n  const returnProps = {\n    ...otherProps,\n    getItemLabel,\n    getItemValue,\n  } as UseItemModelReturn<TItemModel, TAdditionalProps>;\n\n  return returnProps;\n};\n","const escapeReg = /[[\\]{}()*+?.\\\\^$|]/g;\n\nconst escapeRegExp = (str: string) => {\n  return str.replace(escapeReg, \"\\\\$&\");\n};\n\nexport const startsWithPerTerm = <T>(\n  inputValue: string,\n  itemLabel: string\n): boolean => {\n  const reg = new RegExp(\n    `(^|\\\\s)${escapeRegExp(inputValue.toLowerCase())}.*`,\n    \"g\"\n  );\n\n  return reg.test(itemLabel.toLowerCase());\n};\n","import \"@ui5/webcomponents-icons/dist/search.js\";\nimport \"@ui5/webcomponents/dist/features/InputSuggestions.js\";\n\nimport {\n  Input,\n  InputDomRef,\n  InputPropTypes,\n  SuggestionItem,\n  SuggestionItemPropTypes,\n  Ui5CustomEvent,\n} from \"@ui5/webcomponents-react\";\nimport {\n  KeyboardEvent,\n  MutableRefObject,\n  forwardRef,\n  useCallback,\n  useImperativeHandle,\n  useMemo,\n  useRef,\n} from \"react\";\n\nimport { useLatestRef } from \"../../../hook/useLatestRef\";\nimport type { DefaultAutoCompleteOption } from \"../../AutoCompleteModel\";\nimport { triggerSubmitOnEnter, useOnChangeWorkaround } from \"../../util\";\nimport { startsWithPerTerm } from \"./filter\";\n\nexport type { DefaultAutoCompleteOption };\n\nexport type CreatedAutoCompleteOption = DefaultAutoCompleteOption & {\n  __isNew__: true;\n};\n\n/**\n * Base Props of Input we really care about. Reduced prop set of the UI5 Component <code>Input</code>\n * => Controlled Component\n */\nexport type CoreAutocompleteProps<T extends {} = DefaultAutoCompleteOption> =\n  Omit<\n    InputPropTypes,\n    | \"children\"\n    | \"value\"\n    | \"name\"\n    | \"onChange\"\n    | \"onInput\"\n    | \"showSuggestions\"\n    | \"type\"\n  > & {\n    /**\n     * Name of the input.\n     */\n    name?: string;\n\n    /**\n     * Value shown on the input\n     */\n    inputValue?: string;\n\n    /**\n     * Selected suggested item\n     */\n    value?: string;\n\n    /**\n     * Suggestions to show\n     */\n    items: Array<T>;\n\n    /**\n     * Render <code>SuggestionItem</code>s from UI5.\n     */\n    itemProps?: (item: T) => Partial<SuggestionItemPropTypes>;\n\n    /**\n     * Controls which text is used to display options.\n     * Used by suggestions, if not overridden\n     * by <code>renderSuggestion</code>\n     *\n     * By default the prop <code>label</code> is used.\n     * You can pass either a string, which represents a different prop or a render function.\n     */\n    getItemLabel: (item: T) => string;\n\n    /**\n     * Controls which value / key is used to identify an option.\n     * This is used by suggestions, if not overridden\n     * by <code>renderSuggestion</code>.\n     *\n     * By default the prop <code>value</code> is used.\n     * You can pass either a string, which represents a different prop or a render function.\n     */\n    getItemValue: (item: T) => string;\n\n    /**\n     * Change handler that allows to access the new inputValue\n     *\n     * @param inputValue updated input value\n     * @param event event that lead to that change\n     */\n    onInputChange?: (\n      inputValue: string,\n      event: Ui5CustomEvent<InputDomRef>\n    ) => void;\n\n    /**\n     * Change handler that allows to access the new suggested item\n     * Note: will be called in the future without item to reset the value\n     *\n     * @param suggestionValue\n     */\n    onValueChange?: (value?: string, item?: T) => void;\n\n    /**\n     * Custom filter method to display only items matching the search term.\n     *\n     * Note: provide null to disable filtering\n     *\n     * @param suggestionValue\n     */\n    filterItem?: null | ((inputValue: string, item: T) => boolean);\n\n    /**\n     * If user doesn't select a suggested value, her input will be lost if this prop is set to true.\n     * Default: true;\n     */\n    forceSelection?: boolean;\n  };\n\nexport const CoreAutocomplete = forwardRef<InputDomRef, CoreAutocompleteProps>(\n  (props, forwardedRef) => {\n    const {\n      items = [],\n      itemProps,\n      getItemLabel,\n      getItemValue,\n      onInputChange,\n      onValueChange,\n      value,\n      inputValue,\n      filterItem,\n      ...otherProps\n    } = props;\n\n    const valueRef = useLatestRef<string | undefined>(value);\n    const suggestionRef = useLatestRef<Array<DefaultAutoCompleteOption>>(items);\n\n    const customItemFilter: (\n      inputValue: string,\n      item: DefaultAutoCompleteOption\n    ) => boolean = useMemo(() => {\n      if (filterItem === null) {\n        return () => true;\n      }\n\n      if (filterItem != null) {\n        return filterItem;\n      }\n\n      return (inputValue: string, item: DefaultAutoCompleteOption) =>\n        startsWithPerTerm(inputValue ?? \"\", getItemLabel(item) ?? \"\");\n    }, [filterItem, getItemLabel]);\n\n    const filteredItems: Array<DefaultAutoCompleteOption> = useMemo(\n      () =>\n        items.filter(\n          (item) =>\n            (item as CreatedAutoCompleteOption).__isNew__ ||\n            customItemFilter(inputValue ?? \"\", item)\n        ),\n      [inputValue, items, customItemFilter]\n    );\n\n    const handleSuggestionItemSelect = useCallback(\n      (event: Ui5CustomEvent<InputDomRef, { item: HTMLElement }>) => {\n        if (onValueChange == null) {\n          return;\n        }\n\n        const element = event.detail.item as HTMLElement & {\n          text: string;\n        };\n        if (element?.dataset?.id != null) {\n          const itemValue = element?.dataset?.id;\n          const item = suggestionRef.current.find(\n            (item) => getItemValue(item) === itemValue\n          );\n          if (item) {\n            onValueChange(itemValue, item);\n          }\n        }\n      },\n      [onValueChange, getItemValue]\n    );\n\n    const handleInput = useCallback(\n      (event: Ui5CustomEvent<InputDomRef>) => {\n        const currentValue = (event.currentTarget as HTMLInputElement).value;\n\n        if (onInputChange != null) {\n          onInputChange(currentValue, event);\n        }\n\n        if (onValueChange != null) {\n          const item = suggestionRef.current.find(\n            (item) => getItemLabel(item) === currentValue\n          );\n          if (!item && valueRef.current != null) {\n            onValueChange(undefined, undefined);\n          }\n        }\n      },\n      [onInputChange]\n    );\n\n    const handleKeyPress = useCallback((event: KeyboardEvent<HTMLElement>) => {\n      triggerSubmitOnEnter(event);\n    }, []);\n\n    let shownValue: string = inputValue ?? \"\";\n\n    if (value != null) {\n      const item = items.find((item) => getItemValue(item) === value);\n      shownValue = item == null ? value : getItemLabel(item);\n    }\n\n    // store input ref for internal usage\n    const inputRef = useRef<InputDomRef>() as MutableRefObject<InputDomRef>;\n    useImperativeHandle(forwardedRef, () => inputRef.current);\n    // apply workaround to fix onChange event\n    useOnChangeWorkaround(inputRef, value);\n\n    return (\n      <Input\n        {...otherProps}\n        value={shownValue}\n        ref={inputRef}\n        showSuggestions={true}\n        onInput={handleInput}\n        onSuggestionItemSelect={handleSuggestionItemSelect}\n        onKeyPress={handleKeyPress}\n      >\n        {filteredItems.map((item) => {\n          const props: Partial<SuggestionItemPropTypes> = itemProps\n            ? itemProps(item)\n            : {};\n\n          const value = getItemValue(item);\n          const label = props.text || getItemLabel(item);\n\n          return (\n            <SuggestionItem\n              {...props}\n              key={value}\n              data-id={value}\n              text={label}\n            />\n          );\n        })}\n      </Input>\n    );\n  }\n);\n"],"names":["useInputState","props","propsInputValue","propsValue","propsOnInputChange","propsOnValueChange","propsOnBlur","forceSelection","stateInputValue","setStateInputValue","useState","stateValue","setStateValue","latestValueRef","useLatestRef","useEffect","onInputChange","useCallback","inputValue","event","onValueChange","value","item","onBlur","useItemModel","itemValue","itemLabel","otherProps","getItemLabel","DEFAULT_LABEL_PROP","getItemValue","DEFAULT_VALUE_PROP","escapeReg","escapeRegExp","str","startsWithPerTerm","CoreAutocomplete","forwardRef","forwardedRef","items","itemProps","filterItem","valueRef","suggestionRef","customItemFilter","useMemo","inputValue2","filteredItems","handleSuggestionItemSelect","element","_a","_b","item2","handleInput","currentValue","handleKeyPress","triggerSubmitOnEnter","shownValue","inputRef","useRef","useImperativeHandle","useOnChangeWorkaround","jsx","Input","props2","value2","label","createElement","SuggestionItem"],"mappings":"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"}